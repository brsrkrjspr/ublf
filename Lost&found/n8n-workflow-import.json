{
  "name": "UB Lost & Found Chatbot - Natural Conversation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "chatbot"
    },
    {
      "parameters": {
        "jsCode": "// Extract webhook data and prepare context\nconst input = $input.first().json || $input.first() || {};\nconst webhookData = input.body || input.json || input || {};\n\nconst message = (webhookData.message || input.message || '').toLowerCase().trim();\nconst studentNo = webhookData.studentNo || input.studentNo || '';\nconst studentName = webhookData.studentName || input.studentName || '';\nconst studentEmail = webhookData.studentEmail || input.studentEmail || '';\nconst conversationHistory = webhookData.conversationHistory || input.conversationHistory || [];\n\n// Simple optional keyword check for data fetching (non-blocking)\n// This is just a hint - AI will decide what to do with the data\nconst lostFoundKeywords = ['lost', 'found', 'report', 'item', 'my reports', 'search', 'missing'];\nconst needsData = lostFoundKeywords.some(keyword => message.includes(keyword));\n\n// Check for specific query types\nconst needsMyReports = message.includes('my report') || message.includes('my item');\nconst needsAllLostItems = (message.includes('lost') || message.includes('all item')) && !message.includes('my');\nconst needsAllFoundItems = message.includes('found item') && !message.includes('my');\n\nreturn [{\n  json: {\n    originalMessage: webhookData.message || input.message || '',\n    studentNo: studentNo,\n    studentName: studentName,\n    studentEmail: studentEmail,\n    conversationHistory: conversationHistory,\n    needsData: needsData,\n    needsMyReports: needsMyReports,\n    needsAllLostItems: needsAllLostItems,\n    needsAllFoundItems: needsAllFoundItems\n  }\n}];"
      },
      "id": "prepare-context",
      "name": "Prepare Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "needs-my-reports",
              "leftValue": "={{ $json.needsMyReports }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-my-reports",
      "name": "Check My Reports",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "needs-all-lost-items",
              "leftValue": "={{ $json.needsAllLostItems }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-all-lost-items",
      "name": "Check All Lost Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "needs-all-found-items",
              "leftValue": "={{ $json.needsAllFoundItems }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-all-found-items",
      "name": "Check All Found Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [650, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf-2.onrender.com/api/v1/reports.php?studentNo={{ $json.studentNo }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-my-reports",
      "name": "Get My Reports",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf-2.onrender.com/api/v1/reports.php?search={{ $json.originalMessage || '' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-all-lost-items",
      "name": "Get All Lost Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf-2.onrender.com/api/v1/items.php?search={{ $json.originalMessage || '' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-all-found-items",
      "name": "Get All Found Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 400]
    },
    {
      "parameters": {
        "jsCode": "// Merge all inputs: context + optional database results\nconst allInputs = $input.all();\nconst contextData = $('Prepare Context').first().json || {};\n\n// Collect database results\nconst dbResults = {\n  myReports: [],\n  allLostItems: [],\n  allFoundItems: [],\n  all: []\n};\n\nallInputs.forEach((item) => {\n  const data = item.json || {};\n  \n  // Check if this is API response data\n  if (data.data !== undefined || data.success !== undefined) {\n    let results = [];\n    if (data.data && Array.isArray(data.data)) {\n      results = data.data;\n    } else if (data.success && data.data) {\n      if (Array.isArray(data.data)) {\n        results = data.data;\n      } else if (data.data) {\n        results = [data.data];\n      }\n    }\n    \n    // Determine query type from node name or data structure\n    const nodeName = item.node?.name || '';\n    if (nodeName.includes('My Reports')) {\n      dbResults.myReports = results;\n    } else if (nodeName.includes('Lost Items')) {\n      dbResults.allLostItems = results;\n    } else if (nodeName.includes('Found Items')) {\n      dbResults.allFoundItems = results;\n    }\n    \n    dbResults.all.push(...results);\n  }\n});\n\n// Always return context with optional data\nreturn [{\n  json: {\n    originalMessage: contextData.originalMessage || '',\n    studentName: contextData.studentName || '',\n    studentNo: contextData.studentNo || '',\n    conversationHistory: contextData.conversationHistory || [],\n    dbResults: dbResults.all,\n    dbResultsByType: dbResults,\n    hasData: dbResults.all.length > 0\n  }\n}];"
      },
      "id": "merge-context",
      "name": "Merge Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a friendly, helpful, and conversational AI assistant for a University Lost & Found system. You can have natural conversations about anything and help with Lost & Found queries when needed.\n\nYour capabilities:\n- Have natural conversations about any topic (greetings, questions, casual chat, general topics, conversation summaries, asking about previous messages)\n- Help with Lost & Found queries (report lost items, search for items, check status)\n- Remember and reference previous conversation messages\n- Provide summaries of conversations when asked\n\nGuidelines:\n- Be natural, friendly, and conversational\n- Use the provided conversation history to maintain context and remember previous messages\n- If database results are provided, use them to answer Lost & Found queries accurately\n- If no database results are provided, respond naturally based on the conversation\n- For conversation summaries, reference the conversation history provided\n- Keep responses helpful and engaging\n- If user asks about Lost & Found but no data is available, suggest they can report items or search in the dashboard\n\nIMPORTANT: Respond naturally to whatever the user says. You have full conversation history - use it to understand context and respond appropriately. Database results are optional enhancements - respond naturally whether they're present or not."
            },
            {
              "role": "user",
              "content": "={{ (() => {\n  const data = $json || {};\n  const message = data.originalMessage || '';\n  const studentName = data.studentName || '';\n  const studentNo = data.studentNo || '';\n  const conversationHistory = data.conversationHistory || [];\n  const dbResults = data.dbResults || [];\n  const dbResultsByType = data.dbResultsByType || { myReports: [], allLostItems: [], allFoundItems: [], all: [] };\n  const hasData = data.hasData || false;\n  \n  // Build conversation history text\n  let historyText = '';\n  if (conversationHistory && conversationHistory.length > 0) {\n    historyText = '\\n\\nConversation History:\\n';\n    conversationHistory.forEach((msg) => {\n      if (msg.role && msg.content) {\n        const roleLabel = msg.role === 'user' ? 'User' : 'Assistant';\n        historyText += `${roleLabel}: ${msg.content}\\n`;\n      }\n    });\n  }\n  \n  // Build database results text (if available)\n  let dbResultsText = '';\n  if (hasData) {\n    let resultParts = [];\n    \n    if (dbResultsByType.myReports.length > 0) {\n      const approved = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 1 || r.StatusConfirmed === \"1\").length;\n      const pending = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 0 || r.StatusConfirmed === \"0\").length;\n      resultParts.push(`USER'S REPORTS: ${dbResultsByType.myReports.length} total (${approved} approved, ${pending} pending)\\n${JSON.stringify(dbResultsByType.myReports, null, 2)}`);\n    }\n    \n    if (dbResultsByType.allLostItems.length > 0) {\n      resultParts.push(`LOST ITEMS: ${dbResultsByType.allLostItems.length} found\\n${JSON.stringify(dbResultsByType.allLostItems, null, 2)}`);\n    }\n    \n    if (dbResultsByType.allFoundItems.length > 0) {\n      resultParts.push(`FOUND ITEMS: ${dbResultsByType.allFoundItems.length} found\\n${JSON.stringify(dbResultsByType.allFoundItems, null, 2)}`);\n    }\n    \n    if (resultParts.length > 0) {\n      dbResultsText = '\\n\\nDatabase Results:\\n' + resultParts.join('\\n\\n---\\n\\n');\n    }\n  }\n  \n  return `User: ${message}${historyText}\\n\\nStudent: ${studentName} (${studentNo})${dbResultsText}\\n\\nRespond naturally and helpfully to the user's message. Use the conversation history to maintain context. If database results are provided, use them to answer accurately.`;\n})() }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 1000
        }
      },
      "id": "ai-response",
      "name": "AI Response",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [1250, 300],
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": ""
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ (() => {\n  // Extract reply from AI response\n  const aiResponse = $input.first().json;\n  \n  let reply = '';\n  if (aiResponse.choices && aiResponse.choices[0] && aiResponse.choices[0].message) {\n    reply = aiResponse.choices[0].message.content;\n  } else if (aiResponse.message && aiResponse.message.content) {\n    reply = aiResponse.message.content;\n  } else if (aiResponse.content) {\n    reply = aiResponse.content;\n  } else if (aiResponse.output) {\n    reply = aiResponse.output;\n  } else if (typeof aiResponse === 'string') {\n    reply = aiResponse;\n  } else {\n    reply = 'I apologize, but I couldn\\'t generate a response. Please try again.';\n  }\n  \n  // Clean up reply\n  reply = reply.trim();\n  reply = reply.replace(/\\*\\*(.*?)\\*\\*/g, '$1');\n  reply = reply.replace(/\\*(.*?)\\*/g, '$1');\n  reply = reply.replace(/```[\\s\\S]*?```/g, '');\n  \n  const mergedData = $('Merge Context').first().json || {};\n  \n  // Return object directly (n8n will JSON encode it)\n  return {\n    reply: reply,\n    hasResults: mergedData.hasData || false,\n    resultCount: mergedData.dbResults?.length || 0,\n    timestamp: new Date().toISOString()\n  };\n})() }}",
        "options": {}
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "const error = $input.first().json.error || $input.first().json || {};\nconst errorMessage = error.message || error.error || 'Unknown error';\n\nreturn [{\n  json: {\n    reply: 'I encountered an error processing your request. Please try again or contact admin for assistance. You can also use the dashboard to report items directly.',\n    error: errorMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "format-error-response",
      "name": "Format Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "Prepare Context", "type": "main", "index": 0}]]
    },
    "Prepare Context": {
      "main": [
        [
          {"node": "Check My Reports", "type": "main", "index": 0},
          {"node": "Check All Lost Items", "type": "main", "index": 0},
          {"node": "Check All Found Items", "type": "main", "index": 0},
          {"node": "Merge Context", "type": "main", "index": 0}
        ]
      ]
    },
    "Check My Reports": {
      "main": [
        [{"node": "Get My Reports", "type": "main", "index": 0}],
        [{"node": "Merge Context", "type": "main", "index": 0}]
      ]
    },
    "Check All Lost Items": {
      "main": [
        [{"node": "Get All Lost Items", "type": "main", "index": 0}],
        [{"node": "Merge Context", "type": "main", "index": 0}]
      ]
    },
    "Check All Found Items": {
      "main": [
        [{"node": "Get All Found Items", "type": "main", "index": 0}],
        [{"node": "Merge Context", "type": "main", "index": 0}]
      ]
    },
    "Get My Reports": {
      "main": [[{"node": "Merge Context", "type": "main", "index": 0}]]
    },
    "Get All Lost Items": {
      "main": [[{"node": "Merge Context", "type": "main", "index": 0}]]
    },
    "Get All Found Items": {
      "main": [[{"node": "Merge Context", "type": "main", "index": 0}]]
    },
    "Merge Context": {
      "main": [[{"node": "AI Response", "type": "main", "index": 0}]]
    },
    "AI Response": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    },
    "Webhook Trigger": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Prepare Context": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get My Reports": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get All Lost Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get All Found Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Merge Context": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "AI Response": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Format Error Response": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "executionTimeout": 60,
    "saveExecutionProgress": false,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}
