{
  "name": "UB Lost & Found Chatbot - Simplified",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "chatbot"
    },
    {
      "parameters": {
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are an intelligent intent analyzer for a University Lost & Found chatbot. Analyze user messages and determine what database queries are needed. Handle vague and ambiguous queries intelligently.\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"intent\": \"my_reports\" | \"search_lost\" | \"search_found\" | \"general\" | \"help\",\n  \"needsLostItems\": boolean,\n  \"needsMyReports\": boolean,\n  \"needsFoundItems\": boolean,\n  \"searchTerm\": \"extracted item name or null\",\n  \"studentNo\": \"student number if needed for my_reports\",\n  \"reasoning\": \"brief explanation of your analysis\",\n  \"confidence\": number (0-100, how confident you are in the analysis)\n}\n\nIntent Detection Guidelines:\n- \"my_reports\": User wants to see THEIR OWN reports. Consider: past tense about reporting/posting, possessive pronouns (my, mine), questions about their own activity, mentions of \"i reported\", \"i posted\", \"my items\", \"what did i\", \"show me my\". If user has a student number and message is ambiguous, lean towards my_reports.\n- \"search_lost\": User wants to SEARCH/BROWSE lost items (not their own). Consider: present tense searching, \"find\", \"search\", \"anyone lost\", \"looking for\", \"show lost items\" (without \"my\"), browsing behavior.\n- \"search_found\": User wants to SEARCH/BROWSE found items. Consider: \"found items\", \"anyone found\", \"show found items\", browsing found items.\n- \"general\": General questions, greetings, asking how to report, system information.\n- \"help\": User needs help understanding the system.\n\nHandling Ambiguity:\n- If message is vague (e.g., \"show me items\", \"i reported something\"), consider context:\n  * If student number is present and message could be about their own items → set needsMyReports = true\n  * If message could mean browsing → set needsLostItems = true\n  * You can set MULTIPLE flags to true if query is truly ambiguous - the system will query both and synthesize results\n- Use conversation history to understand context and disambiguate\n- When in doubt, err on the side of querying more (set multiple flags) rather than less\n\nBe intelligent and context-aware. Understand nuance, conversation flow, and user intent even from vague statements."
            },
            {
              "role": "user",
              "content": "={{ (() => {\n  const input = $input.first().json || $input.first() || {};\n  const webhookData = input.body || input.json || input || {};\n  const message = webhookData.message || input.message || '';\n  const studentName = webhookData.studentName || input.studentName || '';\n  const studentNo = webhookData.studentNo || input.studentNo || '';\n  const conversationHistory = webhookData.conversationHistory || input.conversationHistory || [];\n  \n  let historyText = '';\n  if (conversationHistory && conversationHistory.length > 0) {\n    const recentHistory = conversationHistory.slice(-4);\n    historyText = '\\n\\nRecent Conversation:\\n';\n    recentHistory.forEach((msg) => {\n      if (msg.role && msg.content) {\n        const roleLabel = msg.role === 'user' ? 'User' : 'Assistant';\n        historyText += `${roleLabel}: ${msg.content}\\n`;\n      }\n    });\n  }\n  \n  return `Analyze this message: ${message}\\n\\nStudent: ${studentName} (${studentNo})${historyText}\\n\\nReturn JSON with intent analysis.`;\n})() }}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 300
        }
      },
      "id": "ai-intent-analysis",
      "name": "AI Intent Analysis",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [450, 300],
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": ""
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response, merge with webhook context, and determine routing\nconst aiResponse = $input.first().json;\nconst webhookInput = $('Webhook Trigger').first().json || {};\nconst webhookData = webhookInput.body || webhookInput.json || webhookInput || {};\n\n// Extract JSON from AI response\nlet aiAnalysis = {};\nlet aiContent = '';\n\nif (aiResponse.choices && aiResponse.choices[0] && aiResponse.choices[0].message) {\n  aiContent = aiResponse.choices[0].message.content;\n} else if (aiResponse.message && aiResponse.message.content) {\n  aiContent = aiResponse.message.content;\n} else if (aiResponse.content) {\n  aiContent = aiResponse.content;\n} else if (aiResponse.output) {\n  aiContent = aiResponse.output;\n} else if (typeof aiResponse === 'string') {\n  aiContent = aiResponse;\n} else {\n  aiAnalysis = aiResponse;\n}\n\n// Parse JSON from AI response\nif (aiContent) {\n  aiContent = aiContent.trim();\n  aiContent = aiContent.replace(/```json\\n?/g, '');\n  aiContent = aiContent.replace(/```\\n?/g, '');\n  \n  try {\n    aiAnalysis = JSON.parse(aiContent);\n  } catch (e) {\n    const jsonMatch = aiContent.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        aiAnalysis = JSON.parse(jsonMatch[0]);\n      } catch (e2) {\n        aiAnalysis = {\n          intent: 'general',\n          needsLostItems: false,\n          needsMyReports: false,\n          needsFoundItems: false,\n          searchTerm: null,\n          reasoning: 'Failed to parse AI response'\n        };\n      }\n    } else {\n      aiAnalysis = {\n        intent: 'general',\n        needsLostItems: false,\n        needsMyReports: false,\n        needsFoundItems: false,\n        searchTerm: null,\n        reasoning: 'No valid JSON found'\n      };\n    }\n  }\n}\n\n// Merge AI analysis with webhook context\nconst mergedData = {\n  originalMessage: webhookData.message || webhookInput.message || '',\n  studentNo: aiAnalysis.studentNo || webhookData.studentNo || webhookInput.studentNo || '',\n  studentName: webhookData.studentName || webhookInput.studentName || '',\n  studentEmail: webhookData.studentEmail || webhookInput.studentEmail || '',\n  conversationHistory: webhookData.conversationHistory || webhookInput.conversationHistory || [],\n  intent: aiAnalysis.intent || 'general',\n  needsLostItems: aiAnalysis.needsLostItems === true,\n  needsMyReports: aiAnalysis.needsMyReports === true,\n  needsFoundItems: aiAnalysis.needsFoundItems === true,\n  searchTerm: aiAnalysis.searchTerm || null,\n  reasoning: aiAnalysis.reasoning || ''\n};\n\n// Return data for routing (IF node will check the boolean flags)\nreturn [{\n  json: mergedData\n}];"
      },
      "id": "parse-intent",
      "name": "Parse Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "jsCode": "// Smart routing: Allow multiple queries if intent is ambiguous\nconst data = $input.first().json || {};\nconst needsLostItems = data.needsLostItems === true;\nconst needsMyReports = data.needsMyReports === true;\nconst needsFoundItems = data.needsFoundItems === true;\n\n// Count how many queries are needed\nconst queryCount = [needsLostItems, needsMyReports, needsFoundItems].filter(Boolean).length;\n\n// If multiple queries needed (ambiguous intent), route to all of them\n// If single query, route to that one\n// If no queries, route to general path\n\nconst outputs = [];\n\nif (needsLostItems) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'lost_items',\n      routeIndex: 0\n    }\n  });\n}\n\nif (needsMyReports) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'my_reports',\n      routeIndex: 1\n    }\n  });\n}\n\nif (needsFoundItems) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'found_items',\n      routeIndex: 2\n    }\n  });\n}\n\n// If no queries needed, send to Prepare Response directly\nif (outputs.length === 0) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'none',\n      routeIndex: -1\n    }\n  });\n}\n\nreturn outputs;"
      },
      "id": "route-intent",
      "name": "Route Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-lost-items",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "lost_items",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-lost-items",
      "name": "Route Lost Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-my-reports",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "my_reports",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-my-reports",
      "name": "Route My Reports",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-found-items",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "found_items",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-found-items",
      "name": "Route Found Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/reports.php?search={{ $json.searchTerm || $json.originalMessage }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-lost-items",
      "name": "Get Lost Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\n// Get context from Parse Intent (all routes share this context)\nconst parseIntentData = $('Parse Intent').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'lost_items',\n    studentNo: parseIntentData.studentNo,\n    searchTerm: parseIntentData.searchTerm,\n    originalMessage: parseIntentData.originalMessage\n  }\n}];"
      },
      "id": "add-lost-items-type",
      "name": "Add Lost Items Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/reports.php?studentNo={{ $json.studentNo }}",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "queryType",
              "value": "={{ $json.queryType }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-my-reports",
      "name": "Get My Reports",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\n// Get context from Parse Intent (all routes share this context)\nconst parseIntentData = $('Parse Intent').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'my_reports',\n    studentNo: parseIntentData.studentNo,\n    searchTerm: parseIntentData.searchTerm,\n    originalMessage: parseIntentData.originalMessage\n  }\n}];"
      },
      "id": "add-my-reports-type",
      "name": "Add My Reports Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/items.php?search={{ $json.searchTerm || $json.originalMessage }}",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "queryType",
              "value": "={{ $json.queryType }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-found-items",
      "name": "Get Found Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\n// Get context from Parse Intent (all routes share this context)\nconst parseIntentData = $('Parse Intent').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'found_items',\n    studentNo: parseIntentData.studentNo,\n    searchTerm: parseIntentData.searchTerm,\n    originalMessage: parseIntentData.originalMessage\n  }\n}];"
      },
      "id": "add-found-items-type",
      "name": "Add Found Items Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "jsCode": "// Merge all paths: combine context with database results and prepare for AI\n// This node receives inputs from HTTP Request nodes OR Route Intent (for general queries)\nconst allInputs = $input.all();\nconst parseIntentData = $('Parse Intent').first().json || {};\n\n// Get context from Parse Intent\nlet context = {\n  originalMessage: parseIntentData.originalMessage || '',\n  studentName: parseIntentData.studentName || '',\n  studentNo: parseIntentData.studentNo || '',\n  conversationHistory: parseIntentData.conversationHistory || [],\n  intent: parseIntentData.intent || 'general',\n  searchTerm: parseIntentData.searchTerm || null,\n  reasoning: parseIntentData.reasoning || '',\n  confidence: parseIntentData.confidence || 100\n};\n\n// Collect database results from HTTP Request nodes, organized by query type\nconst dbResults = {\n  lostItems: [],\n  myReports: [],\n  foundItems: [],\n  all: []\n};\n\nallInputs.forEach((item) => {\n  const data = item.json || {};\n  \n  // Check if this is API response data (has 'data' field or 'success' field)\n  // The \"Add X Type\" nodes add originalMessage, so we check for data.data or data.success instead\n  if (data.data !== undefined || data.success !== undefined) {\n    let results = [];\n    if (data.data && Array.isArray(data.data)) {\n      results = data.data;\n    } else if (data.success && data.data) {\n      if (Array.isArray(data.data)) {\n        results = data.data;\n      } else if (data.data) {\n        results = [data.data];\n      }\n    }\n    \n    // Categorize results based on queryType (added by \"Add X Type\" nodes)\n    const queryType = data.queryType || (data.studentNo && !data.searchTerm ? 'my_reports' : 'lost_items');\n    \n    if (queryType === 'lost_items') {\n      dbResults.lostItems = results;\n    } else if (queryType === 'my_reports') {\n      dbResults.myReports = results;\n    } else if (queryType === 'found_items') {\n      dbResults.foundItems = results;\n    }\n    \n    dbResults.all.push(...results);\n  } else if (data.originalMessage && data.queryType === 'none') {\n    // This is from Route Intent for general queries (no database needed)\n    context = {\n      originalMessage: data.originalMessage || context.originalMessage,\n      studentName: data.studentName || context.studentName,\n      studentNo: data.studentNo || context.studentNo,\n      conversationHistory: data.conversationHistory || context.conversationHistory,\n      intent: data.intent || context.intent,\n      searchTerm: data.searchTerm || context.searchTerm,\n      reasoning: data.reasoning || context.reasoning,\n      confidence: data.confidence || context.confidence\n    };\n  }\n});\n\n// Calculate statistics for better AI response\nconst stats = {\n  totalResults: dbResults.all.length,\n  myReportsCount: dbResults.myReports.length,\n  myReportsApproved: dbResults.myReports.filter(r => r.StatusConfirmed === 1 || r.StatusConfirmed === \"1\").length,\n  myReportsPending: dbResults.myReports.filter(r => r.StatusConfirmed === 0 || r.StatusConfirmed === \"0\").length,\n  lostItemsCount: dbResults.lostItems.length,\n  foundItemsCount: dbResults.foundItems.length\n};\n\nreturn [{\n  json: {\n    originalMessage: context.originalMessage,\n    studentName: context.studentName,\n    studentNo: context.studentNo,\n    conversationHistory: context.conversationHistory,\n    intent: context.intent,\n    searchTerm: context.searchTerm,\n    reasoning: context.reasoning,\n    confidence: context.confidence,\n    dbResults: dbResults.all,\n    dbResultsByType: dbResults,\n    dbResultsCount: dbResults.all.length,\n    stats: stats\n  }\n}];"
      },
      "id": "prepare-response",
      "name": "Prepare Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a helpful, conversational assistant for a University Lost & Found system. Help students:\n- Report lost items\n- Search for lost or found items\n- Check their report status\n- Answer questions about the system\n\nBe natural, friendly, and conversational. Use the provided context and conversation history to give accurate information. Remember previous messages to maintain context.\n\nHandling Database Results:\n- If multiple data sources are provided (e.g., user's own reports AND all lost items), synthesize intelligently:\n  * Explain what was found from each source\n  * If user asked about their own items but also queried general search, clarify: \"You have X reports. Here they are: [list]. There are also Y total lost items in the system.\"\n  * If results are from user's own reports, mention approval status: \"You have X approved reports and Y pending approval. Here are your approved reports: [list].\"\n- If only one data source, present it naturally\n- If no results found, suggest alternatives or next steps\n- Keep responses under 200 words unless listing multiple items\n\nIMPORTANT: All database queries are ALREADY COMPLETE. Provide the complete answer directly. Do NOT say \"wait a moment\" or \"let me check\" - respond with the final answer immediately. Synthesize multiple data sources intelligently when provided."
            },
            {
              "role": "user",
              "content": "={{ (() => {\n  const data = $json || {};\n  const message = data.originalMessage || '';\n  const studentName = data.studentName || '';\n  const studentNo = data.studentNo || '';\n  const conversationHistory = data.conversationHistory || [];\n  const intent = data.intent || 'general';\n  const reasoning = data.reasoning || '';\n  const confidence = data.confidence || 100;\n  const dbResults = data.dbResults || [];\n  const dbResultsByType = data.dbResultsByType || { lostItems: [], myReports: [], foundItems: [], all: [] };\n  const stats = data.stats || {};\n  \n  // Build conversation history text\n  let historyText = '';\n  if (conversationHistory && conversationHistory.length > 0) {\n    const recentHistory = conversationHistory.slice(-8);\n    historyText = '\\n\\nPrevious Conversation History:\\n';\n    recentHistory.forEach((msg) => {\n      if (msg.role && msg.content) {\n        const roleLabel = msg.role === 'user' ? 'User' : 'Assistant';\n        historyText += `${roleLabel}: ${msg.content}\\n`;\n      }\n    });\n  }\n  \n  // Format database results intelligently\n  let dbResultsText = 'No database queries were needed for this request.';\n  \n  if (dbResultsByType.myReports.length > 0 || dbResultsByType.lostItems.length > 0 || dbResultsByType.foundItems.length > 0) {\n    let resultParts = [];\n    \n    if (dbResultsByType.myReports.length > 0) {\n      const approved = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 1).length;\n      const pending = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 0).length;\n      resultParts.push(`USER'S OWN REPORTS: ${dbResultsByType.myReports.length} total (${approved} approved, ${pending} pending approval)\\n${JSON.stringify(dbResultsByType.myReports, null, 2)}`);\n    }\n    \n    if (dbResultsByType.lostItems.length > 0) {\n      resultParts.push(`ALL LOST ITEMS (search results): ${dbResultsByType.lostItems.length} found\\n${JSON.stringify(dbResultsByType.lostItems, null, 2)}`);\n    }\n    \n    if (dbResultsByType.foundItems.length > 0) {\n      resultParts.push(`FOUND ITEMS (search results): ${dbResultsByType.foundItems.length} found\\n${JSON.stringify(dbResultsByType.foundItems, null, 2)}`);\n    }\n    \n    dbResultsText = resultParts.join('\\n\\n---\\n\\n');\n  } else if (intent !== 'general' && intent !== 'help') {\n    dbResultsText = 'Database query executed but no results found.';\n  }\n  \n  // Build context summary\n  let contextSummary = `\\n\\nContext Summary:\\n- Intent: ${intent} (confidence: ${confidence}%)\\n- Reasoning: ${reasoning || 'N/A'}\\n- Student: ${studentName} (${studentNo})\\n- Statistics: ${JSON.stringify(stats, null, 2)}`;\n  \n  return `User Message: ${message}${historyText}\\n\\nStudent: ${studentName} (${studentNo})${contextSummary}\\n\\nDatabase Results:\\n${dbResultsText}\\n\\nProvide a natural, helpful response. If multiple data sources are provided, synthesize them intelligently. If user asked about their own items, mention approval status. Be conversational and helpful.`;\n})() }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 500
        }
      },
      "id": "generate-ai-response",
      "name": "Generate AI Response",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [1850, 300],
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": ""
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ (() => {\n  // Extract and format reply from AI response\n  const aiResponse = $input.first().json;\n  \n  // Extract reply from OpenAI response\n  let reply = '';\n  if (aiResponse.choices && aiResponse.choices[0] && aiResponse.choices[0].message) {\n    reply = aiResponse.choices[0].message.content;\n  } else if (aiResponse.message && aiResponse.message.content) {\n    reply = aiResponse.message.content;\n  } else if (aiResponse.content) {\n    reply = aiResponse.content;\n  } else if (aiResponse.output) {\n    reply = aiResponse.output;\n  } else if (typeof aiResponse === 'string') {\n    reply = aiResponse;\n  } else {\n    reply = 'I apologize, but I couldn\\'t generate a response. Please try again.';\n  }\n  \n  // Clean up reply (remove markdown if present)\n  reply = reply.trim();\n  reply = reply.replace(/\\*\\*(.*?)\\*\\*/g, '$1');\n  reply = reply.replace(/\\*(.*?)\\*/g, '$1');\n  reply = reply.replace(/```[\\s\\S]*?```/g, '');\n  \n  // Get context for metadata\n  const preparedData = $('Prepare Response').first().json || {};\n  const intent = preparedData.intent || 'general';\n  const resultCount = preparedData.dbResultsCount || 0;\n  \n  return JSON.stringify({\n    reply: reply,\n    intent: intent,\n    hasResults: resultCount > 0,\n    resultCount: resultCount,\n    timestamp: new Date().toISOString()\n  });\n})() }}",
        "options": {}
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "jsCode": "const error = $input.first().json.error || $input.first().json || {};\nconst errorMessage = error.message || error.error || 'Unknown error';\n\nreturn [{\n  json: {\n    reply: 'I encountered an error processing your request. Please try again or contact admin for assistance. You can also use the dashboard to report items directly.',\n    error: errorMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "format-error-response",
      "name": "Format Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "AI Intent Analysis", "type": "main", "index": 0}]]
    },
    "AI Intent Analysis": {
      "main": [[{"node": "Parse Intent", "type": "main", "index": 0}]]
    },
    "Parse Intent": {
      "main": [[{"node": "Route Intent", "type": "main", "index": 0}]]
    },
    "Route Intent": {
      "main": [
        [
          {"node": "Route Lost Items", "type": "main", "index": 0},
          {"node": "Route My Reports", "type": "main", "index": 0},
          {"node": "Route Found Items", "type": "main", "index": 0},
          {"node": "Prepare Response", "type": "main", "index": 0}
        ]
      ]
    },
    "Route Lost Items": {
      "main": [
        [{"node": "Get Lost Items", "type": "main", "index": 0}],
        []
      ]
    },
    "Route My Reports": {
      "main": [
        [{"node": "Get My Reports", "type": "main", "index": 0}],
        []
      ]
    },
    "Route Found Items": {
      "main": [
        [{"node": "Get Found Items", "type": "main", "index": 0}],
        []
      ]
    },
    "Get Lost Items": {
      "main": [[{"node": "Add Lost Items Type", "type": "main", "index": 0}]]
    },
    "Add Lost Items Type": {
      "main": [[{"node": "Prepare Response", "type": "main", "index": 0}]]
    },
    "Get My Reports": {
      "main": [[{"node": "Add My Reports Type", "type": "main", "index": 0}]]
    },
    "Add My Reports Type": {
      "main": [[{"node": "Prepare Response", "type": "main", "index": 0}]]
    },
    "Get Found Items": {
      "main": [[{"node": "Add Found Items Type", "type": "main", "index": 0}]]
    },
    "Add Found Items Type": {
      "main": [[{"node": "Prepare Response", "type": "main", "index": 0}]]
    },
    "Prepare Response": {
      "main": [[{"node": "Generate AI Response", "type": "main", "index": 0}]]
    },
    "Generate AI Response": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    },
    "Webhook Trigger": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "AI Intent Analysis": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Parse Intent": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Route Intent": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get Lost Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get My Reports": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get Found Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Prepare Response": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Generate AI Response": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Format Error Response": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "executionTimeout": 60,
    "saveExecutionProgress": false,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}

