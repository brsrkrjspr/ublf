{
  "name": "UB Lost & Found Chatbot - Reasoning First",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chatbot",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "chatbot"
    },
    {
      "parameters": {
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are an intelligent reasoning assistant for a University Lost & Found chatbot. Your job is to THINK through what the user wants and decide what information you need.\n\nThink step by step:\n1. What is the user asking for?\n2. What information do I need to answer this question?\n3. Is the query ambiguous? If so, what clarification might be needed?\n4. What database queries should I make?\n5. Should I query the user's own reports, all lost items, all found items, or multiple sources?\n\nReturn ONLY valid JSON in this exact format:\n{\n  \"reasoning\": \"Your step-by-step reasoning about what the user wants\",\n  \"needsMyReports\": boolean,\n  \"needsAllLostItems\": boolean,\n  \"needsAllFoundItems\": boolean,\n  \"needsClarification\": boolean,\n  \"clarificationQuestion\": \"Question to ask user if query is ambiguous, or null\",\n  \"searchTerm\": \"Item name to search for, or null\",\n  \"studentNo\": \"Student number if needed, or null\",\n  \"confidence\": number (0-100, how confident you are in your analysis)\n}\n\nGuidelines:\n- Use your reasoning to understand context, nuance, and user intent\n- If the user asks about \"my\" items, \"I reported\", \"my reports\" → needsMyReports = true\n- If the user asks about \"all items\", \"total count\", \"everything\", \"how many lost items\" (without \"my\") → needsAllLostItems = true\n- If truly ambiguous (e.g., \"show me items\" after asking about their reports), you can set multiple flags to true\n- If you're not confident, set needsClarification = true and provide a clarificationQuestion\n- Be intelligent - understand conversation flow and context, not just keywords"
            },
            {
              "role": "user",
              "content": "={{ (() => {\n  const input = $input.first().json || $input.first() || {};\n  const webhookData = input.body || input.json || input || {};\n  const message = webhookData.message || input.message || '';\n  const studentName = webhookData.studentName || input.studentName || '';\n  const studentNo = webhookData.studentNo || input.studentNo || '';\n  const conversationHistory = webhookData.conversationHistory || input.conversationHistory || [];\n  \n  let historyText = '';\n  if (conversationHistory && conversationHistory.length > 0) {\n    const recentHistory = conversationHistory.slice(-6);\n    historyText = '\\n\\nRecent Conversation History:\\n';\n    recentHistory.forEach((msg) => {\n      if (msg.role && msg.content) {\n        const roleLabel = msg.role === 'user' ? 'User' : 'Assistant';\n        historyText += `${roleLabel}: ${msg.content}\\n`;\n      }\n    });\n  }\n  \n  return `User Message: ${message}\\n\\nStudent: ${studentName} (${studentNo})${historyText}\\n\\nThink step by step about what the user wants and what information you need. Return JSON with your reasoning and decisions.`;\n})() }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 500
        }
      },
      "id": "ai-reasoning",
      "name": "AI Reasoning",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [450, 300],
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": ""
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI reasoning response and extract decisions\nconst aiResponse = $input.first().json;\nconst webhookInput = $('Webhook Trigger').first().json || {};\nconst webhookData = webhookInput.body || webhookInput.json || webhookInput || {};\n\n// Extract JSON from AI response\nlet aiAnalysis = {};\nlet aiContent = '';\n\nif (aiResponse.choices && aiResponse.choices[0] && aiResponse.choices[0].message) {\n  aiContent = aiResponse.choices[0].message.content;\n} else if (aiResponse.message && aiResponse.message.content) {\n  aiContent = aiResponse.message.content;\n} else if (aiResponse.content) {\n  aiContent = aiResponse.content;\n} else if (aiResponse.output) {\n  aiContent = aiResponse.output;\n} else if (typeof aiResponse === 'string') {\n  aiContent = aiResponse;\n} else {\n  aiAnalysis = aiResponse;\n}\n\n// Parse JSON from AI response\nif (aiContent) {\n  aiContent = aiContent.trim();\n  aiContent = aiContent.replace(/```json\\n?/g, '');\n  aiContent = aiContent.replace(/```\\n?/g, '');\n  \n  try {\n    aiAnalysis = JSON.parse(aiContent);\n  } catch (e) {\n    const jsonMatch = aiContent.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        aiAnalysis = JSON.parse(jsonMatch[0]);\n      } catch (e2) {\n        aiAnalysis = {\n          reasoning: 'Failed to parse AI response',\n          needsMyReports: false,\n          needsAllLostItems: false,\n          needsAllFoundItems: false,\n          needsClarification: true,\n          clarificationQuestion: 'I apologize, but I had trouble understanding your request. Could you please rephrase it?',\n          confidence: 0\n        };\n      }\n    } else {\n      aiAnalysis = {\n        reasoning: 'No valid JSON found',\n        needsMyReports: false,\n        needsAllLostItems: false,\n        needsAllFoundItems: false,\n        needsClarification: true,\n        clarificationQuestion: 'I apologize, but I had trouble understanding your request. Could you please rephrase it?',\n        confidence: 0\n      };\n    }\n  }\n}\n\n// Merge AI analysis with webhook context\nconst mergedData = {\n  originalMessage: webhookData.message || webhookInput.message || '',\n  studentNo: aiAnalysis.studentNo || webhookData.studentNo || webhookInput.studentNo || '',\n  studentName: webhookData.studentName || webhookInput.studentName || '',\n  studentEmail: webhookData.studentEmail || webhookInput.studentEmail || '',\n  conversationHistory: webhookData.conversationHistory || webhookInput.conversationHistory || [],\n  reasoning: aiAnalysis.reasoning || '',\n  needsMyReports: aiAnalysis.needsMyReports === true,\n  needsAllLostItems: aiAnalysis.needsAllLostItems === true,\n  needsAllFoundItems: aiAnalysis.needsAllFoundItems === true,\n  needsClarification: aiAnalysis.needsClarification === true,\n  clarificationQuestion: aiAnalysis.clarificationQuestion || null,\n  searchTerm: aiAnalysis.searchTerm || null,\n  confidence: aiAnalysis.confidence || 0\n};\n\nreturn [{\n  json: mergedData\n}];"
      },
      "id": "parse-reasoning",
      "name": "Parse Reasoning",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "needs-clarification",
              "leftValue": "={{ $json.needsClarification }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-clarification",
      "name": "Check Clarification",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "jsCode": "// Route to appropriate queries based on AI reasoning\nconst data = $input.first().json || {};\nconst needsMyReports = data.needsMyReports === true;\nconst needsAllLostItems = data.needsAllLostItems === true;\nconst needsAllFoundItems = data.needsAllFoundItems === true;\n\nconst outputs = [];\n\n// Route to Get My Reports if needed\nif (needsMyReports) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'my_reports'\n    }\n  });\n}\n\n// Route to Get All Lost Items if needed\nif (needsAllLostItems) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'all_lost_items'\n    }\n  });\n}\n\n// Route to Get All Found Items if needed\nif (needsAllFoundItems) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'all_found_items'\n    }\n  });\n}\n\n// If no queries needed, send to Prepare Response directly\nif (outputs.length === 0) {\n  outputs.push({\n    json: {\n      ...data,\n      queryType: 'none'\n    }\n  });\n}\n\nreturn outputs;"
      },
      "id": "route-queries",
      "name": "Route Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-my-reports",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "my_reports",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-my-reports",
      "name": "Route My Reports",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-all-lost-items",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "all_lost_items",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-all-lost-items",
      "name": "Route All Lost Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "is-all-found-items",
              "leftValue": "={{ $json.queryType }}",
              "rightValue": "all_found_items",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-all-found-items",
      "name": "Route All Found Items",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/reports.php?studentNo={{ $json.studentNo }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-my-reports",
      "name": "Get My Reports",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\nconst parseData = $('Parse Reasoning').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'my_reports',\n    studentNo: parseData.studentNo,\n    searchTerm: parseData.searchTerm,\n    originalMessage: parseData.originalMessage,\n    reasoning: parseData.reasoning\n  }\n}];"
      },
      "id": "add-my-reports-type",
      "name": "Add My Reports Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/reports.php?search={{ $json.searchTerm || '' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-all-lost-items",
      "name": "Get All Lost Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\nconst parseData = $('Parse Reasoning').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'all_lost_items',\n    studentNo: parseData.studentNo,\n    searchTerm: parseData.searchTerm,\n    originalMessage: parseData.originalMessage,\n    reasoning: parseData.reasoning\n  }\n}];"
      },
      "id": "add-all-lost-items-type",
      "name": "Add All Lost Items Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://ublf.x10.mx/api/v1/items.php?search={{ $json.searchTerm || '' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-API-Key",
              "value": "ublf-x10mx-2024-secure-api-key-7a9b3c2d1e4f6g8h"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "get-all-found-items",
      "name": "Get All Found Items",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "jsCode": "// Add queryType to HTTP response data\nconst httpResponse = $input.first().json || {};\nconst parseData = $('Parse Reasoning').first().json || {};\n\nreturn [{\n  json: {\n    ...httpResponse,\n    queryType: 'all_found_items',\n    studentNo: parseData.studentNo,\n    searchTerm: parseData.searchTerm,\n    originalMessage: parseData.originalMessage,\n    reasoning: parseData.reasoning\n  }\n}];"
      },
      "id": "add-all-found-items-type",
      "name": "Add All Found Items Type",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 400]
    },
    {
      "parameters": {
        "jsCode": "// Merge all paths: combine context with database results for AI synthesis\nconst allInputs = $input.all();\nconst parseData = $('Parse Reasoning').first().json || {};\n\n// Get context from Parse Reasoning\nlet context = {\n  originalMessage: parseData.originalMessage || '',\n  studentName: parseData.studentName || '',\n  studentNo: parseData.studentNo || '',\n  conversationHistory: parseData.conversationHistory || [],\n  reasoning: parseData.reasoning || '',\n  confidence: parseData.confidence || 0,\n  searchTerm: parseData.searchTerm || null\n};\n\n// Collect database results, organized by query type\nconst dbResults = {\n  myReports: [],\n  allLostItems: [],\n  allFoundItems: [],\n  all: []\n};\n\nallInputs.forEach((item) => {\n  const data = item.json || {};\n  \n  // Check if this is API response data\n  if (data.data !== undefined || data.success !== undefined) {\n    let results = [];\n    if (data.data && Array.isArray(data.data)) {\n      results = data.data;\n    } else if (data.success && data.data) {\n      if (Array.isArray(data.data)) {\n        results = data.data;\n      } else if (data.data) {\n        results = [data.data];\n      }\n    }\n    \n    // Categorize results based on queryType\n    const queryType = data.queryType || 'unknown';\n    \n    if (queryType === 'my_reports') {\n      dbResults.myReports = results;\n    } else if (queryType === 'all_lost_items') {\n      dbResults.allLostItems = results;\n    } else if (queryType === 'all_found_items') {\n      dbResults.allFoundItems = results;\n    }\n    \n    dbResults.all.push(...results);\n  }\n});\n\n// Calculate statistics\nconst stats = {\n  totalResults: dbResults.all.length,\n  myReportsCount: dbResults.myReports.length,\n  myReportsApproved: dbResults.myReports.filter(r => r.StatusConfirmed === 1 || r.StatusConfirmed === \"1\").length,\n  myReportsPending: dbResults.myReports.filter(r => r.StatusConfirmed === 0 || r.StatusConfirmed === \"0\").length,\n  allLostItemsCount: dbResults.allLostItems.length,\n  allFoundItemsCount: dbResults.allFoundItems.length\n};\n\nreturn [{\n  json: {\n    originalMessage: context.originalMessage,\n    studentName: context.studentName,\n    studentNo: context.studentNo,\n    conversationHistory: context.conversationHistory,\n    reasoning: context.reasoning,\n    confidence: context.confidence,\n    searchTerm: context.searchTerm,\n    dbResults: dbResults.all,\n    dbResultsByType: dbResults,\n    dbResultsCount: dbResults.all.length,\n    stats: stats\n  }\n}];"
      },
      "id": "prepare-synthesis",
      "name": "Prepare Synthesis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "model": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "You are a helpful, conversational assistant for a University Lost & Found system. Help students:\n- Report lost items\n- Search for lost or found items\n- Check their report status\n- Answer questions about the system\n\nBe natural, friendly, and conversational. Use the provided context and conversation history to give accurate information. Remember previous messages to maintain context.\n\nHandling Database Results:\n- If multiple data sources are provided (e.g., user's own reports AND all lost items), synthesize intelligently:\n  * Explain what was found from each source\n  * If user asked about their own items but also queried general search, clarify: \"You have X reports. Here they are: [list]. There are also Y total lost items in the system.\"\n  * If results are from user's own reports, mention approval status: \"You have X approved reports and Y pending approval. Here are your approved reports: [list].\"\n- If only one data source, present it naturally\n- If no results found, suggest alternatives or next steps\n- Keep responses under 200 words unless listing multiple items\n\nIMPORTANT: All database queries are ALREADY COMPLETE. Provide the complete answer directly. Do NOT say \"wait a moment\" or \"let me check\" - respond with the final answer immediately. Synthesize multiple data sources intelligently when provided."
            },
            {
              "role": "user",
              "content": "={{ (() => {\n  const data = $json || {};\n  const message = data.originalMessage || '';\n  const studentName = data.studentName || '';\n  const studentNo = data.studentNo || '';\n  const conversationHistory = data.conversationHistory || [];\n  const reasoning = data.reasoning || '';\n  const confidence = data.confidence || 0;\n  const dbResults = data.dbResults || [];\n  const dbResultsByType = data.dbResultsByType || { myReports: [], allLostItems: [], allFoundItems: [], all: [] };\n  const stats = data.stats || {};\n  \n  // Build conversation history text\n  let historyText = '';\n  if (conversationHistory && conversationHistory.length > 0) {\n    const recentHistory = conversationHistory.slice(-8);\n    historyText = '\\n\\nPrevious Conversation History:\\n';\n    recentHistory.forEach((msg) => {\n      if (msg.role && msg.content) {\n        const roleLabel = msg.role === 'user' ? 'User' : 'Assistant';\n        historyText += `${roleLabel}: ${msg.content}\\n`;\n      }\n    });\n  }\n  \n  // Format database results intelligently\n  let dbResultsText = 'No database queries were needed for this request.';\n  \n  if (dbResultsByType.myReports.length > 0 || dbResultsByType.allLostItems.length > 0 || dbResultsByType.allFoundItems.length > 0) {\n    let resultParts = [];\n    \n    if (dbResultsByType.myReports.length > 0) {\n      const approved = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 1 || r.StatusConfirmed === \"1\").length;\n      const pending = dbResultsByType.myReports.filter(r => r.StatusConfirmed === 0 || r.StatusConfirmed === \"0\").length;\n      resultParts.push(`USER'S OWN REPORTS: ${dbResultsByType.myReports.length} total (${approved} approved, ${pending} pending approval)\\n${JSON.stringify(dbResultsByType.myReports, null, 2)}`);\n    }\n    \n    if (dbResultsByType.allLostItems.length > 0) {\n      resultParts.push(`ALL LOST ITEMS IN DATABASE: ${dbResultsByType.allLostItems.length} found\\n${JSON.stringify(dbResultsByType.allLostItems, null, 2)}`);\n    }\n    \n    if (dbResultsByType.allFoundItems.length > 0) {\n      resultParts.push(`ALL FOUND ITEMS IN DATABASE: ${dbResultsByType.allFoundItems.length} found\\n${JSON.stringify(dbResultsByType.allFoundItems, null, 2)}`);\n    }\n    \n    dbResultsText = resultParts.join('\\n\\n---\\n\\n');\n  } else if (message && !message.match(/^(hi|hello|hey|greetings)/i)) {\n    dbResultsText = 'Database query executed but no results found.';\n  }\n  \n  // Build context summary\n  let contextSummary = `\\n\\nAI Reasoning: ${reasoning || 'N/A'}\\nConfidence: ${confidence}%\\nStudent: ${studentName} (${studentNo})\\nStatistics: ${JSON.stringify(stats, null, 2)}`;\n  \n  return `User Message: ${message}${historyText}\\n\\nStudent: ${studentName} (${studentNo})${contextSummary}\\n\\nDatabase Results:\\n${dbResultsText}\\n\\nProvide a natural, helpful response. If multiple data sources are provided, synthesize them intelligently. If user asked about their own items, mention approval status. Be conversational and helpful.`;\n})() }}"
            }
          ]
        },
        "options": {
          "temperature": 0.7,
          "maxTokens": 500
        }
      },
      "id": "ai-synthesis",
      "name": "AI Synthesis",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [2050, 300],
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": ""
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ (() => {\n  // Extract and format reply from AI response\n  const aiResponse = $input.first().json;\n  \n  // Extract reply from OpenAI response\n  let reply = '';\n  if (aiResponse.choices && aiResponse.choices[0] && aiResponse.choices[0].message) {\n    reply = aiResponse.choices[0].message.content;\n  } else if (aiResponse.message && aiResponse.message.content) {\n    reply = aiResponse.message.content;\n  } else if (aiResponse.content) {\n    reply = aiResponse.content;\n  } else if (aiResponse.output) {\n    reply = aiResponse.output;\n  } else if (typeof aiResponse === 'string') {\n    reply = aiResponse;\n  } else {\n    reply = 'I apologize, but I couldn\\'t generate a response. Please try again.';\n  }\n  \n  // Clean up reply (remove markdown if present)\n  reply = reply.trim();\n  reply = reply.replace(/\\*\\*(.*?)\\*\\*/g, '$1');\n  reply = reply.replace(/\\*(.*?)\\*/g, '$1');\n  reply = reply.replace(/```[\\s\\S]*?```/g, '');\n  \n  // Get context for metadata\n  const preparedData = $('Prepare Synthesis').first().json || {};\n  const resultCount = preparedData.dbResultsCount || 0;\n  \n  return JSON.stringify({\n    reply: reply,\n    hasResults: resultCount > 0,\n    resultCount: resultCount,\n    timestamp: new Date().toISOString()\n  });\n})() }}",
        "options": {}
      },
      "id": "send-response",
      "name": "Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ (() => {\n  const parseData = $('Parse Reasoning').first().json || {};\n  const clarificationQuestion = parseData.clarificationQuestion || 'I need more information to help you. Could you please clarify what you\\'re looking for?';\n  \n  return JSON.stringify({\n    reply: clarificationQuestion,\n    needsClarification: true,\n    timestamp: new Date().toISOString()\n  });\n})() }}",
        "options": {}
      },
      "id": "send-clarification",
      "name": "Send Clarification",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "jsCode": "const error = $input.first().json.error || $input.first().json || {};\nconst errorMessage = error.message || error.error || 'Unknown error';\n\nreturn [{\n  json: {\n    reply: 'I encountered an error processing your request. Please try again or contact admin for assistance. You can also use the dashboard to report items directly.',\n    error: errorMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "format-error-response",
      "name": "Format Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "AI Reasoning", "type": "main", "index": 0}]]
    },
    "AI Reasoning": {
      "main": [[{"node": "Parse Reasoning", "type": "main", "index": 0}]]
    },
    "Parse Reasoning": {
      "main": [[{"node": "Check Clarification", "type": "main", "index": 0}]]
    },
    "Check Clarification": {
      "main": [
        [{"node": "Send Clarification", "type": "main", "index": 0}],
        [{"node": "Route Queries", "type": "main", "index": 0}]
      ]
    },
    "Route Queries": {
      "main": [
        [
          {"node": "Route My Reports", "type": "main", "index": 0},
          {"node": "Route All Lost Items", "type": "main", "index": 0},
          {"node": "Route All Found Items", "type": "main", "index": 0},
          {"node": "Prepare Synthesis", "type": "main", "index": 0}
        ]
      ]
    },
    "Route My Reports": {
      "main": [
        [{"node": "Get My Reports", "type": "main", "index": 0}],
        []
      ]
    },
    "Route All Lost Items": {
      "main": [
        [{"node": "Get All Lost Items", "type": "main", "index": 0}],
        []
      ]
    },
    "Route All Found Items": {
      "main": [
        [{"node": "Get All Found Items", "type": "main", "index": 0}],
        []
      ]
    },
    "Get My Reports": {
      "main": [[{"node": "Add My Reports Type", "type": "main", "index": 0}]]
    },
    "Add My Reports Type": {
      "main": [[{"node": "Prepare Synthesis", "type": "main", "index": 0}]]
    },
    "Get All Lost Items": {
      "main": [[{"node": "Add All Lost Items Type", "type": "main", "index": 0}]]
    },
    "Add All Lost Items Type": {
      "main": [[{"node": "Prepare Synthesis", "type": "main", "index": 0}]]
    },
    "Get All Found Items": {
      "main": [[{"node": "Add All Found Items Type", "type": "main", "index": 0}]]
    },
    "Add All Found Items Type": {
      "main": [[{"node": "Prepare Synthesis", "type": "main", "index": 0}]]
    },
    "Prepare Synthesis": {
      "main": [[{"node": "AI Synthesis", "type": "main", "index": 0}]]
    },
    "AI Synthesis": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    },
    "Webhook Trigger": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "AI Reasoning": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Parse Reasoning": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get My Reports": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get All Lost Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Get All Found Items": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Prepare Synthesis": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "AI Synthesis": {
      "error": [[{"node": "Format Error Response", "type": "main", "index": 0}]]
    },
    "Format Error Response": {
      "main": [[{"node": "Send Response", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "executionTimeout": 60,
    "saveExecutionProgress": false,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}

